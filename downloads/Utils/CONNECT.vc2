*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="connect.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS connmgr AS custom 		&& Connection Manager. Used to keep track of all active connections.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="d:\vfp\samples\graphics\bmps\fox\connectn.bmp" ClassIcon="d:\vfp\samples\graphics\bmps\fox\connectn.bmp" />

	*<DefinedPropArrayMethod>
		*m: aconnect
		*m: closeconnection		&& Close an open connection
		*m: count
		*m: list		&& List all open connections
		*m: openconnection		&& Open a connection
		*p: nconnectioncount		&& The number of open connections
		*a: aconnections[1,0]		&& Holds the open connections
	*</DefinedPropArrayMethod>

	PROTECTED aconnections,nconnectioncount
	Name = "connmgr"
	nconnectioncount = 0		&& The number of open connections
	Picture = f:\vfp\samples\graphics\bmps\fox\connectn.bmp
	
	PROCEDURE aconnect
		* Return an array containing all active connection information
		* Since we're already storing it in an array, 
		* this is as simple as copying the array
		
		PARAMETER aReturn
		EXTERNAL ARRAY aReturn
		
		LOCAL nReturn	&& return value is # of rows or -1
		
		DO CASE
			CASE TYPE("aReturn[1]")="U"
				* Bad parameter, can't do it
				nReturn = -1
			CASE THIS.nConnectionCount=0
				nReturn=0
			OTHERWISE
				* redim the array to get rid of old data
				DIMENSION aReturn[1]
				* Copy from the property into the parameter
				= ACOPY(THIS.aConnections,aReturn)
				nReturn = ALEN(aReturn,1)
		ENDCASE
		
		RETURN nReturn
	ENDPROC

	PROCEDURE closeconnection		&& Close an open connection
		* Close an open connection. Make sure to remove it from the open list
		LPARAMETERS nHandle
			* Which connection to close
			
		* Find out if we have such a connection
		LOCAL nConnectionRow
		nConnectionRow = ASCAN(This.aConnections, nHandle, -1, ;
				-1, 1, 8)
		IF nConnectionRow > 0
			* found it, now get rid of it
			nResult = SQLDISCONNECT(nHandle)
			=ADEL(THIS.aConnections,nConnectionRow)
			THIS.nConnectionCount=THIS.nConnectionCount-1
			IF THIS.nConnectionCount>0
				DIMENSION THIS.aConnections[THIS.nConnectionCount,4]
			ENDIF
		ELSE
			* Turn off the error handler and send the code for the
			* error we want. This lets AERROR() return the right
			* information, but keeps the user from seeing a message.
			LOCAL cOldError
			cOldError=ON("ERROR")
			ON ERROR *
			ERROR 1466
			ON ERROR &cOldError
			nResult = -2
		ENDIF
		
		RETURN nResult
			
	ENDPROC

	PROCEDURE count
		* return the number of connections
		RETURN THIS.nConnectionCount
	ENDPROC

	PROCEDURE list		&& List all open connections
		* List the open connections in the active window
		?"Connection handle","Data Source/Connection","Userid","Password"
		
		IF THIS.nConnectionCount>0
			LOCAL nConn
			FOR nConn = 1 TO THIS.nConnectionCount
				?THIS.aConnections[nConn,1]
				??THIS.aConnections[nConn,2] AT 19
				IF TYPE("THIS.aConnections[nConn,3]")="C"
					??THIS.aConnections[nConn,3] AT 42
				ENDIF
				IF TYPE("THIS.aConnections[nConn,4]")="C"
					??THIS.aConnections[nConn,4] AT 49
				ENDIF
			ENDFOR
			
		ELSE
			?"No Open Connections"
		ENDIF
	ENDPROC

	PROCEDURE openconnection		&& Open a connection
		* Open a connection - based on parameters
		LPARAMETERS cSource,cUserId,cPassword
			* cSource is either datasource name or named connection
			
		LOCAL nHandle
		
		DO CASE
			CASE NOT EMPTY(DBC()) AND INDBC(cSource,"CONNECTION")
				* named connection - go for it
				nHandle = SQLCONNECT(cSource)
			CASE TYPE("cUserId")="C" AND TYPE("cPassword")="C"
				nHandle = SQLCONNECT(cSource,cUserId,cPassword)
			CASE TYPE("cUserId")="C"
				nHandle = SQLCONNECT(cSource,cUserId)
			CASE TYPE("cPassword")="C"
			  	nHandle = SQLCONNECT(cSource,"",cPassword)
			OTHERWISE
				nHandle = SQLCONNECT(cSource)
		ENDCASE
		
		IF nHandle>0
			* successful connection
			* so add this connection to our list
			THIS.nConnectionCount=THIS.nConnectionCount+1
			DIMENSION THIS.aConnections[THIS.nConnectionCount,4]
			THIS.aConnections[THIS.nConnectionCount,1]=nHandle
			THIS.aConnections[THIS.nConnectionCount,2]=cSource
			THIS.aConnections[THIS.nConnectionCount,3]=cUserId
			THIS.aConnections[THIS.nConnectionCount,4]=cPassword
			
		ENDIF
		RETURN nHandle
		
	ENDPROC

ENDDEFINE
